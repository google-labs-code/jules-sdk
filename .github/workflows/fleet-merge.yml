# Copyright 2026 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# .github/workflows/fleet-merge.yml
#
# Sequentially merges Jules-authored PRs: update branch ‚Üí wait for CI ‚Üí squash merge.
# On merge conflict, re-dispatches the task as a new Jules session against current base.
name: Fleet Sequential Merge

on:
  # Allow manual trigger (recommended: review PRs first, then trigger)
  workflow_dispatch:
    inputs:
      base_branch:
        description: "Base branch for merge"
        type: string
        default: "main"

concurrency:
  group: fleet-merge
  cancel-in-progress: false

jobs:
  sequential-merge:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install fleet dependencies
        run: cd scripts/fleet && bun install

      - name: Find and merge fleet PRs sequentially
        run: |
          set -euo pipefail

          BASE_BRANCH="${{ inputs.base_branch || 'main' }}"
          MAX_CI_WAIT=600   # 10 minutes per PR
          MAX_RETRIES=2     # Max re-dispatch attempts per PR
          PR_POLL_TIMEOUT=900  # 15 minutes to wait for re-dispatched PR

          echo "üîç Finding open Jules-authored PRs targeting ${BASE_BRANCH}..."

          # Get all open PRs authored by Jules, sorted by creation date (oldest first)
          PRS=$(gh pr list \
            --state open \
            --base "$BASE_BRANCH" \
            --json number,headRefName,author \
            --jq '[.[] | select(.author.login == "google-labs-jules" or (.author.login | endswith("[bot]")))] | sort_by(.number) | .[].number')

          if [ -z "$PRS" ]; then
            echo "‚ÑπÔ∏è  No Jules-authored PRs found. Nothing to merge."
            exit 0
          fi

          PR_COUNT=$(echo "$PRS" | wc -l | tr -d ' ')
          echo "Found ${PR_COUNT} Jules PR(s) to merge."

          for PR_NUM in $PRS; do
            echo ""
            echo "üì¶ Processing PR #${PR_NUM}..."
            RETRY_COUNT=0

            while true; do
              # Update branch from base
              echo "  üîÑ Updating branch from ${BASE_BRANCH}..."
              UPDATE_OUTPUT=$(gh pr update-branch "$PR_NUM" --rebase 2>&1) || true

              # Check for merge conflict
              if echo "$UPDATE_OUTPUT" | grep -qi "conflict\|cannot be rebased"; then
                if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                  echo "  ‚ùå Conflict persists after ${MAX_RETRIES} retries. Human intervention required."
                  echo "  PR: $(gh pr view "$PR_NUM" --json url --jq '.url')"
                  exit 1
                fi

                echo "  ‚ö†Ô∏è Merge conflict detected. Re-dispatching task..."

                # Get the PR's task prompt from the fleet data
                TASK_PROMPT=$(gh pr view "$PR_NUM" --json body --jq '.body')

                # Close the conflicting PR
                echo "  üîí Closing conflicting PR #${PR_NUM}..."
                gh pr close "$PR_NUM" --comment "‚ö†Ô∏è Closed by fleet-merge: merge conflict detected. Task re-dispatched as a new session."

                # Re-dispatch via Jules SDK
                echo "  üöÄ Re-dispatching against current ${BASE_BRANCH}..."
                REPO_FULL="${{ github.repository }}"
                NEW_SESSION_ID=$(bun -e "
                  import { jules } from '@google/jules-sdk';
                  const session = await jules.createSession({
                    prompt: process.env.TASK_PROMPT,
                    source: { github: '${REPO_FULL}', baseBranch: '${BASE_BRANCH}' },
                  });
                  console.log(session.id);
                " 2>/dev/null)
                echo "  üìù New session: ${NEW_SESSION_ID}"

                # Poll for new PR
                echo "  ‚è≥ Waiting for new PR from session ${NEW_SESSION_ID}..."
                POLL_ELAPSED=0
                NEW_PR_NUM=""
                while [ $POLL_ELAPSED -lt $PR_POLL_TIMEOUT ]; do
                  sleep 30
                  POLL_ELAPSED=$((POLL_ELAPSED + 30))
                  NEW_PR_NUM=$(gh pr list --state open --base "$BASE_BRANCH" --json number,headRefName,body \
                    --jq "[.[] | select(.headRefName | contains(\"${NEW_SESSION_ID}\")) // select(.body | contains(\"${NEW_SESSION_ID}\"))] | .[0].number // empty")
                  if [ -n "$NEW_PR_NUM" ]; then
                    echo "  ‚úÖ New PR #${NEW_PR_NUM} found."
                    break
                  fi
                  echo "  ‚è≥ No PR yet... (${POLL_ELAPSED}s/${PR_POLL_TIMEOUT}s)"
                done

                if [ -z "$NEW_PR_NUM" ]; then
                  echo "  ‚ùå Timed out waiting for re-dispatched PR. Human intervention required."
                  exit 1
                fi

                PR_NUM="$NEW_PR_NUM"
                RETRY_COUNT=$((RETRY_COUNT + 1))
                continue
              fi

              # Wait for branch update to propagate
              sleep 5

              # Wait for CI checks to pass
              echo "  üß™ Waiting for CI checks..."
              ELAPSED=0
              CI_PASSED=false

              while [ $ELAPSED -lt $MAX_CI_WAIT ]; do
                STATUS=$(gh pr checks "$PR_NUM" --json name,state --jq '[.[].state] | if length == 0 then "none" elif all(. == "SUCCESS" or . == "SKIPPED") then "pass" elif any(. == "FAILURE") then "fail" else "pending" end')

                case "$STATUS" in
                  "pass")
                    CI_PASSED=true
                    break
                    ;;
                  "none")
                    echo "  ‚ÑπÔ∏è  No CI checks configured. Proceeding."
                    CI_PASSED=true
                    break
                    ;;
                  "fail")
                    echo "  ‚ùå CI failed for PR #${PR_NUM}. Skipping."
                    break
                    ;;
                  *)
                    echo "  ‚è≥ CI pending... (${ELAPSED}s/${MAX_CI_WAIT}s)"
                    sleep 30
                    ELAPSED=$((ELAPSED + 30))
                    ;;
                esac
              done

              if [ "$CI_PASSED" = false ]; then
                echo "  ‚è≠Ô∏è  Skipping PR #${PR_NUM} (CI did not pass)"
              else
                # Squash merge
                echo "  ‚úÖ CI passed. Merging PR #${PR_NUM}..."
                if gh pr merge "$PR_NUM" --squash; then
                  echo "  üéâ PR #${PR_NUM} merged successfully."
                else
                  echo "  ‚ùå Failed to merge PR #${PR_NUM}. Stopping sequential merge."
                  exit 1
                fi
              fi

              # Exit the retry loop for this PR
              break
            done

            # Brief pause for merge to propagate before next PR
            sleep 5
          done

          echo ""
          echo "‚úÖ Sequential merge complete."
